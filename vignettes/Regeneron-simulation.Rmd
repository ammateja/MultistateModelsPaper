---
title: "Analysis of a simulated dataset based on the REGEN-2069 trial"
author: "Allyson Mateja, Rapha&euml;l Morsomme, C. Jason Liang, Dean A. Follmann, Meagan P. O'Brien, Chenguang Wang, Jonathan Fintzi"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    code_folding: hide
vignette: >
  %\VignetteIndexEntry{Analysis of a simulated dataset based on the REGEN-2069 trial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning=FALSE, 
  message=FALSE,
  comment = "#>"
)
set.seed(1)
```

# Overview

This vignette demonstrates how to simulate and analyze data with a similar structure to the Regeneron data used as a motivating example in the paper "Assessing treatment efficacy for interval censored endpoints using multistate semi-Markov models fit to multiple data streams". This simulation uses R code to connect to the `MultistateModels.jl` Julia package. 

# Installation and Setup

First, ensure `Julia` (<span>&#8805;</span> version 1.10) is installed. Julia can be downloaded from https://julialang.org/downloads/. Julia must be added to the system PATH; instructions can be found here: https://julialang.org/downloads/platform/. After installing Julia, ensure that the `JuliaConnectoR` R package has been installed and loaded. This package depends on having R version <span>&#8805;</span> 3.2).

```{r, class.source='fold-show', warning=FALSE, message=F}
#install.packages("JuliaConnectoR")
library(JuliaConnectoR)
```

Once the `JuliaConnectoR` package is loaded, the following code can be run to ensure Julia is installed correctly:

```{r, class.source='fold-show'}
JuliaConnectoR::juliaSetupOk()
```

If `Julia` is properly installed, this will return `TRUE`. If `FALSE` is returned, it means that `Julia` has not been installed correctly. See the help page for the `JuliaConnectoR-package` for more details. 

`dplyr`, `ggplot2`, `knitr`, and `kableExtra` are also required for this vignette:

```{r, class.source='fold-show', warning=FALSE, message=F}
#install.packages("dplyr")
#install.packages("ggplot2")
#install.packages("knitr")
#install.packages("kableExtra")
library(ggplot2)
library(dplyr)
```

The necessary Julia functions can be installed by running the following code:

```{r, class.source='fold-show', warning=FALSE, message=F}
if (JuliaConnectoR::juliaSetupOk()){
    JuliaConnectoR::juliaEval('
       import Pkg
       Pkg.add(url = "https://github.com/fintzij/MultistateModels.jl#biostatistics_manuscript_2024")
       Pkg.add("CSV")
       Pkg.add("DataFrames")
       Pkg.add("Random")
       Pkg.add("Chain")
       Pkg.add("Distributions")
       Pkg.add("DataFramesMeta")')
  } else {
    stop("Julia setup incorrect.
         Ensure Julia version >= 1.10 is properly installed.")
  }
```


If there is an error, see the help page for the `JuliaConnectoR-package` for more details. 

# Simulated Data

Data were simulated from a semi-Markov model with nine states - a na&iuml;ve uninfected state, and eight post-infection states characterized by symptom history, PCR positivity, and seroconversion. The transitions from na&iuml;ve to PCR+ without symptoms and from PCR+ without symptoms to diseased were assigned Weibull transition intensities, while the remainder of the transitions had exponential intensities. We set the simulation parameters so that subjects receiving mAb have lower rates of infection and seroconversion along with shorter duration of PCR positivity.

```{r, echo=FALSE, fig.cap="Direct transitions between states in the model for clinical and immunological progression from which participant histories were simulated.", purl=F}
knitr::include_graphics("full_model.PNG")
```


```{r, echo=FALSE, fig.cap="Parameterization and parameter values for transition intensities in the simulation model.", purl=F}
knitr::include_graphics("full_model_params.PNG")
```


# Data Analysis

First, we ensure that the necessary Julia packages are loaded. 

Then, we set up the function `makepars` in Julia to set the baseline intensities for each transition, depending on the model number. Model numbers 1 and 2 are for the full 9-state model, while model numbers 3 and 4 are for the collapsed 5-state model, as used for the Regeneron data. 

```{r, class.source='fold-show', warning=FALSE, message=F}
JuliaConnectoR::juliaEval("using Chain
                          using DataFrames
                          using DataFramesMeta
                          using Random
                          using Distributions
                          using MultistateModels
                          ")
```


```{r, warning=FALSE, message=FALSE}
invisible(JuliaConnectoR::juliaEval("# function to make the parameters
function makepars(; model_number = 1, nulleff = 1)
    te = 2 - nulleff == 1

    if model_number <= 2
        parameters = (h12 = [log(0.7), log(0.6), log(0.33) * te],
                      h23 = [log(0.2), log(0.5) * te],
                      h24 = [log(0.5), log(1.4) * te],
                      h35 = [log(0.5), log(1.4) * te],
                      h45 = [log(0.3), log(0.5) * te],
                      h26 = [log(1.5), log(1), log(0.4) * te],
                      h67 = [log(1), log(0.5) * te],
                      h68 = [log(0.3), log(1.4) * te],
                      h79 = [log(0.3), log(1.4) * te],
                      h89 = [log(1), log(0.5) * te])
    else
        parameters = (h12 = [log(0.7), log(0.6), log(0.33) * te],
                      h23 = [log(0.5), log(1.4) * te],
                      h24 = [log(1.5), log(1), log(0.5) * te],
                      h45 = [log(0.3), log(1.4) * te])
    end
    return parameters
end"))
```

The Julia function below will simulate the PCR assessment times. 

```{r, warning=FALSE, message=F}
invisible(JuliaConnectoR::juliaEval("# function to make the PCR assessment times
function makepcrs(;ntimes=4)

    if ntimes == 4
        times = [0.0; [1.0, 2.0, 3.0] .+ (rand(Beta(3, 3), 3) .- 0.5) .* 0.5; 4.0]
    elseif ntimes == 1
        times = [0.0, 4.0]
    end
    
    return times
end"))
```

We start with the full 9-state model; a data set is created using simulated PCR assessment times based on the `makepcrs` function above, a multistate model is initialized for simulation, and the transition intensities are set to the starting values as described in `makepars`.  

Sample paths are then simulated for each subject.

```{r, warning=FALSE, message=F}
invisible(JuliaConnectoR::juliaEval('# function to set up the model
function setup_full_model(; make_pars, data = nothing, ntimes = 4, nulleff = 1, SamplingWeights = nothing, n_per_arm = 800)
    
    # create hazards
    h12 = Hazard(@formula(0 ~ 1 + mab), "wei", 1, 2)
    h23 = Hazard(@formula(0 ~ 1 + mab), "exp", 2, 3)
    h24 = Hazard(@formula(0 ~ 1 + mab), "exp", 2, 4)
    h35 = Hazard(@formula(0 ~ 1 + mab), "exp", 3, 5)
    h45 = Hazard(@formula(0 ~ 1 + mab), "exp", 4, 5)
    h26 = Hazard(@formula(0 ~ 1 + mab), "wei", 2, 6)
    h67 = Hazard(@formula(0 ~ 1 + mab), "exp", 6, 7)
    h68 = Hazard(@formula(0 ~ 1 + mab), "exp", 6, 8)
    h79 = Hazard(@formula(0 ~ 1 + mab), "exp", 7, 9)
    h89 = Hazard(@formula(0 ~ 1 + mab), "exp", 8, 9)

    # data for simulation parameters
    if isnothing(data)
        visitdays = [makepcrs(;ntimes = ntimes) for i in 1:(2*n_per_arm)]
        data = DataFrame(id = repeat(collect(1:(2 * n_per_arm )), inner = ntimes),
                    tstart = reduce(vcat, map(x -> x[Not(end)], visitdays)),
                    tstop = reduce(vcat, map(x -> x[Not(1)], visitdays)),
                    statefrom = fill(1, 2 * n_per_arm * ntimes),
                    stateto = fill(1, 2 * n_per_arm * ntimes),
                    obstype = fill(1, 2 * n_per_arm * ntimes),
                    mab = repeat([0.0, 1.0], inner = n_per_arm * ntimes),
                    covid = 0.0,
                    sero  = 0.0)
    end

    if isnothing(SamplingWeights)
        SamplingWeights = ones(Float64, length(unique(data.id)))
    end

    # create model
    model = multistatemodel(h12, h23, h24, h35, h45, h26, h67, h68, h79, h89; data = data, SamplingWeights = SamplingWeights)

    # set parameters
    if make_pars
        parameters = makepars(; model_number = 1, nulleff = nulleff)
        set_parameters!(model, parameters) 
    end

    # return model
    return model
end'))

invisible(JuliaConnectoR::juliaEval("Random.seed!(123)"))
invisible(JuliaConnectoR::juliaEval("model_full_sim = setup_full_model(; make_pars = true, data = nothing, nulleff = 1, n_per_arm = 800)"))

paths <- invisible(JuliaConnectoR::juliaEval("paths = simulate(model_full_sim; nsim = 1, paths = true, data = false)[:,1]"))
```

```{r, warning=FALSE, message=FALSE}
pathsR <- JuliaConnectoR::juliaGet(paths)
paths_list <- lapply(pathsR, function(x){data.frame(id=rep(x$subj, length(x$times)), times=x$times, states=x$states)})
paths_df <- do.call("rbind", paths_list)
```

Below we show concatenated sample paths from the first 8 subjects from the full 9-state model. Data are continuously observed, and in this model, serology was assessed weekly. 


```{r, echo=FALSE, purl=F}
knitr::kable(head(paths_df, n=30), "html") %>% kableExtra::kable_styling() %>% kableExtra::scroll_box(width = "800px", height = "300px")
```


In reality, serology was not assessed weekly so we can't fit the simulation model as it is not identifiable. Therefore, we fit the collapsed model shown below and and incorporate serology as explained in the manuscript. 

To get from the nine-state model to the five-state model, states 2 + 3, 4 + 5, 6 + 7, and 8 + 9 are collapsed together. 

Functions below collapse the full 9-state model into the smaller 5-state model. In `observe_subjdat`, we combine the observed visit times for each subject with their simulated sample paths. 

```{r, warning=FALSE, message=F}
invisible(JuliaConnectoR::juliaEval('# function to set up the model
function setup_collapsed_model(; make_pars, data, model_number, ntimes = 4, nulleff = 1, SamplingWeights = nothing)
    
    # create hazards
    if model_number == 3
        h12 = Hazard(@formula(0 ~ 1 + mab), "wei", 1, 2)
        h23 = Hazard(@formula(0 ~ 1 + mab), "exp", 2, 3)
        h24 = Hazard(@formula(0 ~ 1 + mab), "wei", 2, 4)
        h45 = Hazard(@formula(0 ~ 1 + mab), "exp", 4, 5)
    elseif model_number == 4
        h12 = Hazard(@formula(0 ~ 1 + mab), "sp", 1, 2, degree = 1, knots = 5/7, boundaryknots = [0.0, 4.0])
        h23 = Hazard(@formula(0 ~ 1 + mab), "sp", 2, 3, degree = 1, knots = 1.0, boundaryknots = [0.0, 4.0])
        h24 = Hazard(@formula(0 ~ 1 + mab), "sp", 2, 4, degree = 1, knots = 1.0, boundaryknots = [0.0, 4.0])
        h45 = Hazard(@formula(0 ~ 1 + mab), "sp", 4, 5, degree = 1, knots = 1.0, boundaryknots = [0.0, 4.0])        
    end

    if isnothing(SamplingWeights)
        SamplingWeights = ones(Float64, length(unique(data.id)))
    end
    
    # censoring patterns
    censoring_patterns = [3 1 0 1 0 0]
    
    # create model
    model = multistatemodel(h12, h23, h24, h45; data = data, SamplingWeights = SamplingWeights, CensoringPatterns = censoring_patterns)

    # set parameters
    if make_pars
        parameters = makepars(; model_number = 3, nulleff = nulleff)
        set_parameters!(model, parameters) 
    end

    # return model
    return model
end'))

invisible(JuliaConnectoR::juliaEval('# function to collapse path from 9 states to 5
function collapse_path(path_full)
    times  = path_full.times
    states = path_full.states

    # recode
    states[findall(states .== 1)]         .= -1
    states[findall(states .∈ Ref([2,3]))] .= -2
    states[findall(states .∈ Ref([4,5]))] .= -3
    states[findall(states .∈ Ref([6,7]))] .= -4
    states[findall(states .∈ Ref([8,9]))] .= -5

    states .*= -1

    # indices
    inds = [0; findall(states[Not(1)] .!= states[Not(end)])] .+ 1

    # tack on last state and time if not absorbing
    if (last(states, 2) == [1,1]) | (last(states, 2) == [2,2]) | (last(states, 2) == [4,4])
        push!(inds, length(states))
    end

    # remove duplicates
    states = states[inds]
    times  = times[inds]

    return MultistateModels.SamplePath(path_full.subj, times, states)
end'))

invisible(JuliaConnectoR::juliaEval("# function to wrangle a path to subject data
function observe_subjdat_full(path, model)
    # grab subject's data
    i = path.subj
    subj_dat_raw = model.data[model.subjectindices[i], :]

    # make dataset
    ntimes  = length(path.times) - 1 
    subjdat = DataFrame(
        id = fill(path.subj, ntimes),
        tstart = path.times[Not(end)],
        tstop = path.times[Not(1)],
        statefrom = path.states[Not(end)],
        stateto = path.states[Not(1)],
        obstype = fill(1, ntimes),
        mab = fill(subj_dat_raw.mab[1], ntimes))
    
    # tack on PCR, symptoms, sero
    subjdat[:,:pcrpos] = ifelse.(subjdat.stateto .∈ Ref([2,3,6,7]), 1, 0)
    subjdat[:,:covid] = ifelse.(subjdat.stateto .> 5, 1, 0)
    subjdat[:,:sero] = ifelse.(subjdat.stateto .∈ Ref([3,5,7,9]), 1, 0)

    # cull out redundant observations in absorbing states
    subjdat = subjdat[Not(((subjdat.stateto .== 5) .& (subjdat.statefrom .== 5)) .| ((subjdat.stateto .== 9) .& (subjdat.statefrom .== 9))), :]

    # exit
    return subjdat
end

function observe_subjdat_panel(path, model)

    # grab subject's data
    i = path.subj
    subj_dat_raw = model.data[model.subjectindices[i], :]

    # sequences of times and states
    obstimes = unique(sort([0.0; subj_dat_raw.tstop; path.times[findall(path.states .== 6)]]))
    obsinds  = searchsortedlast.(Ref(path.times), obstimes)
    obsstates = path.states[obsinds]

    # if there is a 1->6 observation insert a ghost times
    if any((obsstates[Not(end)] .== 1) .& (obsstates[Not(1)] .== 6))
        # insert time and state
        push!(obstimes, path.times[findfirst(path.states .== 6)] - sqrt(eps()))
        push!(obsstates, 2)

        # reorder
        ord = sortperm(obstimes)
        obstimes = obstimes[ord]
        obsstates = obsstates[ord]

        # make sure there is no delta less than sqrt(eps())
        if any(diff(obstimes) .< sqrt(eps()))
            obstimes .+= collect(0:(length(obstimes)-1)) * sqrt(eps())
        end
    end
    
    # make data
    ntimes  = length(obstimes) - 1 
    subjdat = DataFrame(
        id = fill(path.subj, ntimes),
        tstart = obstimes[Not(end)],
        tstop = obstimes[Not(1)],
        statefrom = obsstates[Not(end)],
        stateto = obsstates[Not(1)],
        obstype = fill(2, ntimes),
        mab = fill(subj_dat_raw.mab[1], ntimes))

    # tack on PCR, symptoms, sero
    subjdat[:,:pcr] = ifelse.(subjdat.stateto .∈ Ref([2,3,6,7]), 1, 0)
    subjdat[:,:covid] = ifelse.(subjdat.stateto .> 5, 1, 0)
    subjdat[:,:sero] = ifelse.(subjdat.stateto .∈ Ref([3,5,7,9]), 1, 0)

    # correct obstype
    if any(subjdat.stateto .== 6)
        subjdat.obstype[findfirst(subjdat.stateto .== 6)] = 1
    end

    # cull out redundant observations in absorbing states
    subjdat = subjdat[Not(((subjdat.stateto .== 5) .& (subjdat.statefrom .== 5)) .| ((subjdat.stateto .== 9) .& (subjdat.statefrom .== 9))), :]

    # exit
    return subjdat
end

function observe_subjdat_collapsed(path, model)

    # grab subject's data
    i = path.subj
    subj_dat_raw = model.data[model.subjectindices[i], :]

    # get serology 
    sero = any(path.states .∈ Ref([3,5,7,9]))

    # collapse path
    path = collapse_path(deepcopy(path))

    # sequences of times and states
    obstimes = unique(sort([0.0; subj_dat_raw.tstop; path.times[findall(path.states .== 4)]]))
    obsinds  = searchsortedlast.(Ref(path.times), obstimes)
    obsstates = path.states[obsinds]

    # if there is a 1->6 observation insert a ghost times
    if any((obsstates[Not(end)] .== 1) .& (obsstates[Not(1)] .== 4))
        # insert time and state
        push!(obstimes, path.times[findfirst(path.states .== 4)] - sqrt(eps()))
        push!(obsstates, 2)

        # reorder
        ord = sortperm(obstimes)
        obstimes = obstimes[ord]
        obsstates = obsstates[ord]

        # make sure there is no delta less than sqrt(eps())
        if any(diff(obstimes) .< sqrt(eps()))
            obstimes .+= collect(0:(length(obstimes)-1)) * sqrt(eps())
        end
    end
    
    # make data
    ntimes  = length(obstimes) - 1 
    subjdat = DataFrame(
        id = fill(path.subj, ntimes),
        tstart = obstimes[Not(end)],
        tstop = obstimes[Not(1)],
        statefrom = obsstates[Not(end)],
        stateto = obsstates[Not(1)],
        obstype = fill(2, ntimes),
        mab = fill(subj_dat_raw.mab[1], ntimes))

    # tack on PCR, symptoms, sero
    subjdat[:,:pcr]   = ifelse.(subjdat.stateto .∈ Ref([2,4]), 1, 0)
    subjdat[:,:covid] = ifelse.(subjdat.stateto .> 3, 1, 0)
    subjdat[:,:sero] .= sero
    
    # correct obstype
    if any(subjdat.stateto .== 4)
        subjdat.obstype[findfirst(subjdat.stateto .== 4)] = 1
    elseif sero & !any(subjdat.covid .== 1) & !any(subjdat.pcr .== 1)
        subjdat.stateto[Not(end)] .= 0
        subjdat.stateto[end]       = 3
        subjdat.statefrom[Not(1)] .= 0
        subjdat.obstype[Not(end)] .= 3
    end
    
    # cull out redundant observations in absorbing states
    subjdat = subjdat[Not(((subjdat.stateto .== 3) .& (subjdat.statefrom .== 3)) .| ((subjdat.stateto .== 5) .& (subjdat.statefrom .== 5))), :] 

    # exit
    return subjdat
end

# wrapper
function observe_subjdat(path, model, model_number)
    if model_number == 1
        subjdat = observe_subjdat_full(path, model)
    elseif model_number == 2
        subjdat = observe_subjdat_panel(path, model)
    else
        subjdat = observe_subjdat_collapsed(path, model)
    end
    return subjdat
end"))
```


The analysis of the REGEN-2069 trial data aims to characterize the effect of mAb on infection and seroconversion, and to quantify the duration of PCR positivity. Inference is based on the model, shown below, which has a na&iuml;ve uninfected state, and four post-infection states characterized by symptom history and whether SARS-CoV-2 infection is, or has ceased to be, detectable by PCR. 

In this example, clinical histories for 1600 participants (800 per arm) are simulated in a hypothetical study to mimic data from the REGEN-2069 trial. PCR data was assessed approximately weekly for 4 weeks, with some variability between participants to reflect the reality of a real-world trial. Symptom onset was observed continuously, and serology assessment was conducted at baseline and at the last study visit. 


```{r, echo=FALSE, fig.cap="Model for infection, symptoms, and seroconversion. Solid arrows represent transitions. Dash-dotted lines depict final serology status.", purl=F}
knitr::include_graphics("REGEN.PNG")
```


The collapsed data set using Weibull and exponential transition intensities (model number 3) is shown below (only the first 30 rows are displayed). Each row represents a time interval (with start and stop times `tstart` and `tstop`), with states at `tstart` shown in `statefrom` and states at `tstop` shown in `stateto`. Generally, `obstype` is set to 2 as the exact time of that transition is unknown. `obstype` = 1 when the transition is directly observed (e.g. death). Notice that 24 participants in the mAb arm and 70 participants in the placebo arm are identified only by serology and hence we encode their unknown state in the `obstype` variable in the data so the software knows to treat this as a latent state where either compartment 1 or 3 are possible.

The variable `mab` represents the treatment arm, and `pcr`, `covid` and `sero` represent PCR testing results, symptoms, and and serology results, respectively, at each transition. 


```{r, warning=FALSE, message=F}
dat <- JuliaConnectoR::juliaEval("dat = reduce(vcat, map(x -> observe_subjdat(x, model_full_sim, 3), paths))")

df <- as.data.frame(JuliaConnectoR::juliaEval("dat"))
```


```{r, echo=FALSE, purl=F}
knitr::kable(head(df, n=30), "html") %>% kableExtra::kable_styling() %>% kableExtra::scroll_box(width = "800px", height = "300px")
```

The table below shows a summary of the data:

```{r, warning=FALSE, message=FALSE, echo=FALSE}
table_s16 <- df %>% 
  group_by(id, mab) %>% 
  summarize(n_covid = sum(covid, na.rm=T), n_sero = sum(as.numeric(sero, na.rm=T)), 
            n_pcr = sum(pcr, na.rm=T)) %>%
  mutate(group = ifelse(n_covid==0 & n_sero == 0 & n_pcr == 0, 1, 
         ifelse(n_covid==0 & n_sero > 0 & n_pcr == 0, 2, 
                ifelse(n_covid==0 & n_sero == 0 & n_pcr > 0, 3, 
                       ifelse(n_covid==0 & n_sero > 0 & n_pcr > 0, 4, 
                              ifelse(n_covid > 0 & n_sero == 0 & n_pcr > 0, 5, 
                                     ifelse(n_covid > 0 & n_sero > 0 & n_pcr > 0, 6, NA))))))) %>%
  ungroup() %>%
  group_by(group, mab) %>%
  summarize(n=n()) %>%
  as.data.frame() %>%
  mutate(mab=factor(mab, levels = c(1, 0), labels = c("mAb", "Placebo"))) %>% 
  arrange(group, mab) %>%
  tidyr::pivot_wider(names_from = "mab", values_from = "n") %>%
  mutate(Symp = c("No", "No", "No", "No", "Yes", "Yes"), `PCR+` = c("No", "No", "Yes", "Yes", "Yes", "Yes"), 
         `Sero+` = c("No", "Yes", "No", "Yes", "No", "Yes"))

names(table_s16)[c(2:3)] <- c("mAb (N=800)", "Placebo (N=800)")
```

```{r, echo=FALSE, purl=F}
knitr::kable(table_s16[ ,c(4:6, 2:3)], "html") %>% kableExtra::kable_styling()
```


We can now re-create the collapsed model with the simulated data. We initialize parameters to set the starting values of the transition intensities to MLEs of the Markov model and fit the model, which is now setup for inference. 


```{r, warning=FALSE, message=F}
invisible(JuliaConnectoR::juliaEval("Random.seed!(0)"))
invisible(JuliaConnectoR::juliaEval("sims_per_subj = 100"))
invisible(JuliaConnectoR::juliaEval("# initialize bookkeeping for weights
            subjweights = @chain dat begin
                groupby(:id)
                @combine(:mab = first(:mab),
                        :sero = first(:sero),
                        :weight = 1.0)
            end"))
```


```{r, warning=FALSE, message=F}
invisible(JuliaConnectoR::juliaEval("# wrapper to fit the collapsed model to npos or nneg
function fit_collapsed(dat; model_number, SamplingWeights = nothing)

    # fit to npos and nneg
    model_fit = setup_collapsed_model(; make_pars = false, data = dat, SamplingWeights = SamplingWeights, model_number = model_number)

    # initialize model parameters
    initialize_parameters!(model_fit; crude = true)
    initialize_parameters!(model_fit)

    # fit models
    model_fitted = fit(model_fit; verbose = true, compute_vcov = false, maxiter = 500, ess_target_initial = 100, ascent_threshold = 0.2, stopping_threshold = 0.2, tol = 0.01)

    return model_fitted
end"))

invisible(JuliaConnectoR::juliaEval("model_fitted = fit_collapsed(dat; model_number = 3, SamplingWeights = subjweights.weight)"))
```


In order to obtain the maximum likelihood estimates for functionals of interest, we simulate 100 paths per subject from this fitted model, without bootstraping (indicated by setting seed2 equal to 0). 


```{r, warning=FALSE, message=F}
invisible(JuliaConnectoR::juliaEval("# remake dataset for prediction
function make_dat4pred(dat; obstype=2) 
    data = @chain dat begin
        groupby(:id)
        @combine(:tstart = 0.0,
                 :tstop = 4.0,
                 :statefrom = 1,
                 :stateto = 1,
                 :obstype = obstype,
                 :mab = first(:mab), 
                 :covid = maximum(:covid),
                 :sero = first(:sero))
    end
end"))

invisible(JuliaConnectoR::juliaEval("# to determine if ever PCR+
function pcrdetec(path; full = true)
    
    # code events 
    covid = full ? 6 : 4
    pcrpos = full ? [2,3,6,7] : [2,4]
    
    # identify the states at the observation times
    obsstates = path.states[searchsortedlast.(Ref(path.times), collect(0.0:4.0))]
    
    # return 0 or 1 if detected
    detected = any(obsstates .∈ Ref(pcrpos)) 

    return detected
end"))

invisible(JuliaConnectoR::juliaEval("# to calculate the probability of detection
function pcr_detectprob(paths, full)

    # find infected
    infected = map(x -> x.states[2] > 1, paths)

    # observe subjdat
    detected = pcrdetec.(paths; full = full)

    # probability of detection given infection
    probdetec = map((x,y) -> sum(y) == 0 ? missing : sum(x[findall(y .== 1)]) / sum(y), eachrow(detected), eachrow(infected))

    return probdetec
end"))


invisible(JuliaConnectoR::juliaEval("# to determine if an infection is detected
function pcrdur_collapsed(paths_pred)

    # identify paths with infections
    infected = map(x -> x.states[2] > 1, paths_pred)

    # get durations
    pcrstart = map(x -> x.states[2] > 1 ? x.times[2] : 0.0, paths_pred)

    pcrstop = map(x -> 
        x.states[2] == 1 ? 0.0 : 
        last(x.states) ∈ [2,4] ? last(x.times) : 
        x.times[findfirst(x.states .∈ Ref([3,5]))], paths_pred)

    pcrdur = pcrstop .- pcrstart

    # compute the average duration among the infected
    durs = map((x,y) -> any(y) ? mean(x[y]) : missing, eachrow(pcrdur), eachrow(infected))

    return durs
end"))

invisible(JuliaConnectoR::juliaEval('# summarize paths
function summarize_paths_collapsed(paths_pred, model_pred; return_counts = false)

    # initialize data
    dat = deepcopy(model_pred.data)

    # summarize stateto-statefrom data at the individual level
    gdat = groupby(dat, :id)
    dat = combine(gdat,
        :covid => (x -> any(x.==1)) => :covid,
        :sero => (x -> any(x.==1)) => :sero,
        :mab => (x -> any(x.==1)) => :mab
    )

    # matrices with events
    infected = [any(x.states .> 1) for x in paths_pred]
    symptomatic = [any(x.states .> 3) for x in paths_pred]
    asymptomatic = infected .- symptomatic
    infectime = [any(x.states .> 1) ? x.times[findfirst(x.states .> 1)] : 4.0 for x in paths_pred]

    # observed in the data - not derived from simulated paths
    dat[:,:serosympt]  = dat[:,:sero] .* dat[:,:covid]
    dat[:,:seroasympt] = dat[:,:sero] .- dat[:,:serosympt]

    # tabulate for npos
    dat[:,:weight]       = model_pred.SamplingWeights
    dat[:,:infected]    .= mean(infected, dims = 2)
    dat[:,:symptomatic] .= mean(symptomatic, dims = 2)
    dat[:,:asymptomatic] = dat.infected .- dat.symptomatic
    dat[:,:infectime]   .= mean(infectime, dims = 2)

    # get probability of detection|infection and pcr+ duration
    dat[:,:pcrdur] = pcrdur_collapsed(paths_pred)
    dat[:,:pcrdetect] = pcr_detectprob(paths_pred, false)

     # summarize by mab
    counts = @chain dat begin
        groupby(:mab)
        @combine(:N = sum(:weight),
                # model estimates 
                 :i = sum(:infected),
                 :s = sum(:symptomatic),
                 :a = sum(:asymptomatic),
                 # from data
                 :sero = sum(:sero .* :weight),
                 :serosym = sum(:serosympt .* :weight),
                 :seroasym = sum(:seroasympt .* :weight),
                 # model estimates
                 :rmt_i = mean(:infectime),
                 :pcrdur = mean(:pcrdur[.!ismissing.(:pcrdur)]),
                 :pcrdetect = mean(:pcrdetect[.!ismissing.(:pcrdetect)]))
    end

    # collect estimates
    ests_wide = @chain counts begin
        groupby(:mab)
        @combine(:i = :i ./ :N,
                 :s = :s ./ :N,
                 :a = :a ./ :N,
                 :s_i = :s ./ :i,
                 :a_i = :a ./ :i,
                 :n_i = :sero ./ :i,
                 :n_s = :serosym ./ :s,
                 :n_a = :seroasym ./ :a,
                 :rmti = :rmt_i,
                 :pcrdur = :pcrdur,
                 :pcrdetect = :pcrdetect)
    end

    # stack the estimates
    ests = @chain ests_wide begin
        stack(Not(:mab))
        @transform(@byrow :var = :variable * (:mab == 1.0 ? "_m" : "_p"))
        @select($(Not(:mab, :variable)))
        @select(:var, :value)
    end 

    # add in contrasts
    append!(ests, DataFrame(
            var = ["pe_infec", 
                   "pe_sym", 
                   "pe_asym", 
                   "eff_sym_infec", 
                   "eff_n_infec", 
                   "eff_n_sym", 
                   "eff_n_asym"],
            value = [1 .- ests.value[ests.var .== "i_m"] ./ ests.value[ests.var .== "i_p"];
                     1 .- ests.value[ests.var .== "s_m"] ./ ests.value[ests.var .== "s_p"];
                     1 .- ests.value[ests.var .== "a_m"] ./ ests.value[ests.var .== "a_p"];
                     ests.value[ests.var .== "s_i_m"] ./ ests.value[ests.var .== "s_i_p"];
                     ests.value[ests.var .== "n_i_m"] ./ ests.value[ests.var .== "n_i_p"];
                     ests.value[ests.var .== "n_s_m"] ./ ests.value[ests.var .== "n_s_p"];
                     ests.value[ests.var .== "n_a_m"] ./ ests.value[ests.var .== "n_a_p"]]))

    if return_counts
        return counts
    else
        return ests
    end
end'))

invisible(JuliaConnectoR::juliaEval("# wrapper to fit the collapsed model to npos or nneg
function get_paths_pred_collapsed(model_fitted; sims_per_subj, model_number)

    # models for prediction
    model_pred = setup_collapsed_model(; make_pars = false, data = make_dat4pred(model_fitted.data), SamplingWeights = model_fitted.SamplingWeights, model_number = model_number)

    # set parameters
    set_parameters!(model_pred, model_fitted.parameters)
   
    # simulate paths
    paths_pred = simulate(model_pred; nsim = sims_per_subj, paths = true, data = false)

    return paths_pred
end"))


invisible(JuliaConnectoR::juliaEval("# wrapper to fit the collapsed model to npos or nneg
function get_estimates_collapsed(model_fitted; sims_per_subj, model_number)

    # models for prediction
    model_pred = setup_collapsed_model(; make_pars = false, data = make_dat4pred(model_fitted.data), SamplingWeights = model_fitted.SamplingWeights, model_number = model_number)

    # set parameters
    set_parameters!(model_pred, model_fitted.parameters)
   
    # simulate paths
    paths_pred = simulate(model_pred; nsim = sims_per_subj, paths = true, data = false)

    # summarize paths
    ests = summarize_paths_collapsed(paths_pred, model_pred)

    # exit
    return ests
end"))

paths_pred <- JuliaConnectoR::juliaEval("paths_pred = get_paths_pred_collapsed(model_fitted; sims_per_subj = sims_per_subj, model_number = 3)")
ests <- as.data.frame(JuliaConnectoR::juliaCall("DataFrame", JuliaConnectoR::juliaEval("ests = get_estimates_collapsed(model_fitted; sims_per_subj = sims_per_subj, model_number = 3)")))


ests$var <- c("Pr(Infec. | Plac.)", "Pr(Infec. | mAb)", "Pr(Sympt. | Plac.)", "Pr(Sympt. | mAb)", "Pr(Asympt. | Plac.)", "Pr(Asympt. | mAb)", "Pr(Sympt. | Infec., Plac.)", "Pr(Sympt. | Infec., mAb)", "Pr(Asympt. | Infec., Plac.)", "Pr(Asympt. | Infec., mAb)", "Pr(N+ | Infec., Plac.)", "Pr(N+ | Infec., mAb)", "Pr(N+ | sympt., Plac.)", "Pr(N+ | sympt., mAb)", "Pr(N+ | asympt., Plac.)", "Pr(N+ | asympt., mAb)", "RM TI | Plac.", "RM TI | mAb", "RM PCR+ | Plac.", "RM PCR+ | mAb", "Pr(Detected | Plac.)", "Pr(Detected | mAb)", "PE for infec.", "PE for sympt. infec.", "PE for asympt. infec.", "RR for sympt. | infec.", "RR for N+ | infec.", "RR for N+ | sympt.", "RR for N+ | asympt.")
```


```{r, echo=F, purl=F}
knitr::kable(ests, "html", digits=3) %>% kableExtra::kable_styling() %>% kableExtra::scroll_box(width = "800px", height = "300px")
```

Pr = Probability, RMIFT = restricted mean infection free time, RM PCR+ = restricted mean duration of PCR+, PE = protective efficacy, RR = relative risk, N+ = seropositive. RM TI is the arithmetic mean over individuals of the the predicted days to infection or maximum follow-up for each individual, whichever is less. RM PCR+ is the arithmetic mean days during which individuals are detectable by PCR or the maximum follow-up for each individual, whichever is less. RR is the ratio of probabilities of the specified event, mAb divided by placebo. PE is 1 - RR, i.e., the reduction in relative risk.



```{r, echo=F}
paths_predR <- JuliaConnectoR::juliaGet(paths_pred)
#paths_pred_fullR <- JuliaConnectoR::juliaGet(paths_pred_full)

dat2 <- JuliaConnectoR::juliaEval("dat2 = reduce(vcat, map(x -> observe_subjdat(x, model_full_sim, 2), paths))")
df2 <- as.data.frame(JuliaConnectoR::juliaEval("dat2"))


times <- seq(0, 4, 0.05)
times_new <- seq(0, 4, 0.01)

any_infection <- df2 %>% group_by(id) %>%
  mutate(n=n(), any_infection = ifelse(sum(pcr) >= 1 | sum(sero) >= 1 | sum(covid) >= 1, 1, 0), 
         time_infection = ifelse(any_infection==0, 0, min(tstop[pcr==1 | sero==1 | covid==1]))) %>%
  slice_head()
 
inc_any_mab <- rep(0, length(times))
inc_any_placebo <- rep(0, length(times))
 
for (i in 1:length(times)) {
 
   inc_any_mab[i] <- nrow(any_infection[any_infection$mab==1 & any_infection$time_infection <= times[i] & any_infection$any_infection==1, ])
   inc_any_placebo[i] <- nrow(any_infection[any_infection$mab==0 & any_infection$time_infection <= times[i] & any_infection$any_infection==1, ])
   
}
 
incidence1 <- data.frame(times = rep(times*7, 2), inc=c(inc_any_mab/800, inc_any_placebo/800), group=c(rep("mAb", length(times)), rep("Placebo", length(times))))


inc_confirmed_mod <- rep(0, length(paths_predR))
ids <- rep(0, length(paths_predR))

for (i in 1:length(paths_predR)) {
  
  if (paths_predR[[i]]$states[2] > 1) {
    ids[i] <- paths_predR[[i]]$subj
    inc_confirmed_mod[i] <- paths_predR[[i]]$times[2]
  } 

}

confirmed_infection_model <- data.frame(id=ids, time_infection=inc_confirmed_mod, confirmed_infection = ifelse(inc_confirmed_mod==0, 0, 1)) %>%
  left_join(any_infection[ ,c("id", "mab")], by="id")


inc_confirmed_mab_mod <- rep(0, length(times_new))
inc_confirmed_placebo_mod <- rep(0, length(times_new))

for (i in 1:length(times_new)) {
  
  inc_confirmed_mab_mod[i] <- nrow(confirmed_infection_model[confirmed_infection_model$mab==1 & confirmed_infection_model$time_infection <= times_new[i] & confirmed_infection_model$confirmed_infection==1, ])
  inc_confirmed_placebo_mod[i] <- nrow(confirmed_infection_model[confirmed_infection_model$mab==0 & confirmed_infection_model$time_infection <= times_new[i] & confirmed_infection_model$confirmed_infection==1, ])
  
}

incidence2 <- data.frame(times = rep(times_new*7, 2), inc=c(inc_confirmed_mab_mod/80000, inc_confirmed_placebo_mod/80000), group=c(rep("mAb", length(times_new)), rep("Placebo", length(times_new))))
```



```{r, echo=F}

confirmed_infection <- df %>% group_by(id) %>%
   mutate(n=n(), confirmed_infection = ifelse(sum(covid) >= 1, 1, 0), 
          time_infection = ifelse(confirmed_infection==0, 0, min(tstop[covid==1 | pcr==1]))) %>%
   slice_head()
 
inc_confirmed_mab <- rep(0, length(times))
inc_confirmed_placebo <- rep(0, length(times))
 
for (i in 1:length(times)) {
   
   inc_confirmed_mab[i] <- nrow(confirmed_infection[confirmed_infection$mab==1 & confirmed_infection$time_infection <= times[i] & confirmed_infection$confirmed_infection==1, ])
   inc_confirmed_placebo[i] <- nrow(confirmed_infection[confirmed_infection$mab==0 & confirmed_infection$time_infection <= times[i] & confirmed_infection$confirmed_infection==1, ])
   
}
 
incidence_conf1 <- data.frame(times = rep(times*7, 2), inc=c(inc_confirmed_mab/800, inc_confirmed_placebo/800), group=c(rep("mAb", length(times)), rep("Placebo", length(times))))






inc_confirmed_mod_full <- rep(0, length(paths_predR))
ids_full <- rep(0, length(paths_predR))

for (i in 1:length(paths_predR)) {
  
  if (sum(as.numeric(c(4) %in% paths_predR[[i]]$states)) >= 1) {
    ids_full[i] <- paths_predR[[i]]$subj
    inc_confirmed_mod_full[i] <- min(paths_predR[[i]]$times[paths_predR[[i]]$states %in% c(4)])
  } 

}

confirmed_infection_model_full <- data.frame(id=ids_full, time_infection=inc_confirmed_mod_full, confirmed_infection = ifelse(inc_confirmed_mod_full==0, 0, 1)) %>%
  left_join(confirmed_infection[ ,c("id", "mab")], by="id")


inc_confirmed_mab_mod_full <- rep(0, length(times_new))
inc_confirmed_placebo_mod_full <- rep(0, length(times_new))

for (i in 1:length(times_new)) {
  
  inc_confirmed_mab_mod_full[i] <- nrow(confirmed_infection_model_full[confirmed_infection_model_full$mab==1 & confirmed_infection_model_full$time_infection <= times_new[i] & confirmed_infection_model_full$confirmed_infection==1, ])
  inc_confirmed_placebo_mod_full[i] <- nrow(confirmed_infection_model_full[confirmed_infection_model_full$mab==0 & confirmed_infection_model_full$time_infection <= times_new[i] & confirmed_infection_model_full$confirmed_infection==1, ])
  
}

incidence_conf2 <- data.frame(times = rep(times_new*7, 2), inc=c(inc_confirmed_mab_mod_full/80000, inc_confirmed_placebo_mod_full/80000), group=c(rep("mAb", length(times_new)), rep("Placebo", length(times_new))))


```


The plot below shows the cumulative incidence of confirmed COVID-19 infection (A) and all-comer/any infection (B) by treatment arm. 
Dots are from the initial simulated data. Solid lines correspond to the pointwise 
maximum likelihood estimates.

```{r, fig.height=6, fig.width=8, echo=F}
ggplot() + 
  geom_point(data=incidence_conf1, aes(x=times, y=inc, col=factor(group, levels = c("Placebo", "mAb")))) + 
  geom_line(data=incidence_conf2, aes(x=times, y=inc, col=factor(group, levels = c("Placebo", "mAb"))), lwd=1) +
  theme_bw() +
  scale_color_manual(values = c("darkred", "blue")) +
  labs(y = "Cumulative Incidence", x = "Days Since Enrollment", col = "Treatment", title="A", subtitle = "Confirmed COVID-19") +
  scale_x_continuous(breaks = seq(0, 28, 7)) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2))
```



```{r, fig.height=6, fig.width=8, echo=F}
ggplot() + 
  geom_point(data=incidence1, aes(x=times, y=inc, col=factor(group, levels = c("Placebo", "mAb")))) + 
  geom_line(data=incidence2, aes(x=times, y=inc, col=factor(group, levels = c("Placebo", "mAb"))), lwd=1) +
  theme_bw() +
  scale_color_manual(values = c("darkred", "blue")) +
  labs(y = "Cumulative Incidence", x = "Days Since Enrollment", col = "Treatment", title="B", subtitle = "All-comer infection") +
  scale_x_continuous(breaks = seq(0, 28, 7)) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2))
```



The `work_function` shown below is the wrapper for one simulation. To reproduce the results in the paper, you can simulate 1,000,000 data sets (each with 100 simulations per subject), where seed1 is sequenced from 1:1000, and seed2 is sequenced from 0:1001 for each value of seed1. Model number 3 represents the collapsed 5-state model used to fit the data from the REGEN-2069 trial. Source code for the data analysis can be found: https://github.com/ammateja/MultistateModelsPaper/tree/master/simulations%20source%20code%20and%20results.


```{r, warning=FALSE, message=F}
invisible(JuliaConnectoR::juliaEval("# wrapper for one simulation
function work_function(;seed1, seed2, model_number, nulleff)

    Random.seed!(seed1)

    # set up model for simulation
    model_full_sim = setup_full_model(; make_pars = true, data = nothing, nulleff = nulleff, n_per_arm = 800)
        
    # simulate paths
    paths = simulate(model_full_sim; nsim = 1, paths = true, data = false)[:,1]

    # make dataset
    dat = reduce(vcat, map(x -> observe_subjdat(x, model_full_sim, model_number), paths))

    # set second seed
    Random.seed!(seed2)

    ### set up model for fitting
    # set sims_per_subj
    sims_per_subj = 100

    # subject weights
    if seed2 == 0
        # initialize bookkeeping for weights
        subjweights = @chain dat begin
            groupby(:id)
            @combine(:mab = first(:mab),
                     :sero = first(:sero),
                     :weight = 1.0)
        end
    else
        # initialize bookkeeping for weights
        subjweights = @chain dat begin
            groupby(:id)
            @combine(:mab = first(:mab),
                     :sero = first(:sero))
            groupby(:mab)
            @transform(:weight = length(:id) * vec(rand(Dirichlet(ones(length(:id))),1)))
         end
    end

    # fit models
    model_fitted = fit_collapsed(dat; model_number = model_number, SamplingWeights = subjweights.weight)
        
    # get estimates
    ests = get_estimates_collapsed(model_fitted; sims_per_subj = sims_per_subj, model_number = model_number)
        
    ### return results
    return DataFrame(simnum = seed1, iter = seed2, model_number = model_number, var = ests.var, est = ests.value)
end"))
```




